# pathToRegexp-demo

### 乌龙

目标是找到譬如'/whole-2B126'路劲中的2、126参数，如果使用‘/whole-:id(\d+)B:dd(\d+)’是不管用的，
生成的正则都是d+而不是我们所期待\d+

如果换成/whole-:id(\\d+)B:dd(\\d+)，恭喜你，变成了\\d+，就是这么的不尽人意

so...只能用/whole-:id([0-9]+)B:dd([0-9]+)

问题何在？
'(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
发现多次采用非捕获性分组？：先无视它
'(\\:(\\w+)(\\(((\\\\.|[^\\\\()])+)\\))?|\\(((\\\\.|[^\\\\()])+)\\))([+*?])?'
依旧不清楚，把转义去掉
'(\:(\w+)(\(((\\.|[^\\()])+)\))?|\(((\\.|[^\\()])+)\))([+*?])?'
我们似乎看到了\(和\)的配对，这个正是自定义正则的内容
((\\.|[^\\()])+)
貌似没问题啊，如果我用\\d+应该可以输出\d+呀

为此特地在浏览器的console下试了一遍
/(\\.|[^\\()])+/g.exec('\\d+')
输出
 ["\d+", "+", index: 0, input: "\d+", groups: undefined]
完美！！

But，在node下运行同样的代码结果：
[ '\\d+', '+', index: 0, input: '\\d+' ]

原来，终端打印的转义\的时候会再加一层转义
为此特地增加
console.log('\d')
console.log('\\d')
加以测试
输出
d
\d

我们再把原来的模板改成/whole-:id(\\d+)B:dd(\\d+)
输出
[ { name: 'type',
    prefix: '/',
    delimiter: '/',
    optional: false,
    repeat: false,
    partial: true,
    pattern: '[^\\/]+?' },
  { name: 'city',
    prefix: '',
    delimiter: '/',
    optional: false,
    repeat: false,
    partial: false,
    pattern: '\\d+' },
  { name: 'dir',
    prefix: '',
    delimiter: '/',
    optional: false,
    repeat: false,
    partial: false,
    pattern: '\\d+' } ]

至此这段乌龙结束

### cookie中包含中文怎么办？

cookie中为何要包含中文？可能是测试哥哥姐姐的恶作剧（展示他们测试能力）

而我们能做的就是没有500，思路很简单利用中间件删掉中文cookie（你不仁我不义）

关键如何判断是否为中文呢？上正则！
一般中文检测正则：/[\u4e00-\u9fa5]/g
然并卵，第一这个有局限，只是除掉中文就可以了吗？no，还有日文、阿拉伯等等，非我族类其心必异，这些奇文都会cookie报错；第二这个正则真的可以找到中文吗？no，cookie在传输的时候早就把中文进行了编码处理，你在node端得到的早就不是以前的她了。
怎样的字符才是cookie接收的呢？答案就在ascii表里，纵观整个ascii表最大code值为0x7f，也就是我们平时判断全角还是半角用的charcode为128的界限，终于找到明白人了！
最终的正则为：/[^\u0000-\u0080]/




